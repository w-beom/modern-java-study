# chapter18 함수형 관점으로 생각하기

### 이 장의 내용

- 왜 함수형 프로그래밍을 사용하는가?
- 함수형 프로그래밍은 어떻게 정의하는가?
- 선언형 프로그래밍과 참조 투명성
- 함수형 스타일의 자바 구현 가이드라인
- 반복과 재귀

## 시스템 구현과 유지보수

프로그램을 쉽게 유지보수할 수 있으려면 프로그램이 어떤 모습이어야 할까?

프로그램이 시스템의 구조를 이해하기 쉽게 클래스 계층으로 반영한다면 좋을 것이다.

시스템의 각 부분의 상호 의존성을 가리키는 `결합성`과 시스템의 다양한 부분이 서로 어떤 관계를 갖는지 가리키는 `응집성` 이라는 소프트웨어 엔지니어링 도구로 프로그램 구조를 평가할 수 있다.

그러나 실질적으로 많은 프로그래머가 유지보수 중 코드 크래시 디버깅 문제를 가장 많이 겪게된다.

코드 크래시는 예상하지 못한 변숫값 때문에 발생할 수 있다.

왜, 그리고, 어떻게 변숫값이 바뀐걸까? 유지보수 중 이런 일이 얼마나 자주 일어나는지 생각해보라

함수형 프로그래밍이 제공하는 `부작용 없음`과 `불변성` 이라는 개념이 이 문제를 해결하는 데 도움을 준다.

### 공유된 가변 데이터

변수가 예상하지 못한 값을 갖는 이유는 결국 우리가 유지보수하는 시스템의 여러 메서드에서 공유된 변수가 어딘가에서 변화가 일어나기 때문이다.

하나의 List를 참조하는 여러개의 클래스가 있다고 가정하자. 과연 이 List의 소유자는 어느 클래스 일까?

이처럼 공유하는 가변 데이터를 사용하면 프로그램 전체에서 데이터 갱신하는 위치를 추적하기가 어려워진다.

![chapter18%20%E1%84%92%E1%85%A1%E1%86%B7%E1%84%89%E1%85%AE%E1%84%92%E1%85%A7%E1%86%BC%20%E1%84%80%E1%85%AA%E1%86%AB%E1%84%8C%E1%85%A5%E1%86%B7%E1%84%8B%E1%85%B3%E1%84%85%E1%85%A9%20%E1%84%89%E1%85%A2%E1%86%BC%E1%84%80%E1%85%A1%E1%86%A8%E1%84%92%E1%85%A1%E1%84%80%E1%85%B5%2074f084ea904e450ba3f59dc3a5fb581c/Untitled.png](chapter18%20%E1%84%92%E1%85%A1%E1%86%B7%E1%84%89%E1%85%AE%E1%84%92%E1%85%A7%E1%86%BC%20%E1%84%80%E1%85%AA%E1%86%AB%E1%84%8C%E1%85%A5%E1%86%B7%E1%84%8B%E1%85%B3%E1%84%85%E1%85%A9%20%E1%84%89%E1%85%A2%E1%86%BC%E1%84%80%E1%85%A1%E1%86%A8%E1%84%92%E1%85%A1%E1%84%80%E1%85%B5%2074f084ea904e450ba3f59dc3a5fb581c/Untitled.png)

여러 클래스에서 리스트를 변경할 수 있어 데이터가 수정되면 추적하기가 어려워진다.

어떤 자료구조도 바꾸지 않는 시스템이 있다고 가정하자.

예상하지 못하게 자료구조의 값이 바뀔 일이 없으니 얼마나 유지보수 하기가 쉬울까?

자신을 포함하는 클래스의 상태 그리고 다른 객체의 상태를 바꾸지 않으며 return 문을 통해서만 자신의 결과를 반환하는 메서드를 `순수 메서드` 또는 `부작용 없는 메서드`라고 부른다.

다음은 부작용의 예이다

- 자료구조를 고치거나 필드에 값을 할당 (setter 메서드 같은 생성자 이외의 초기화 동작)
- 예외발생
- 파일에 쓰기 등의 I/O 동작 수행

`불변 객체`를 이용해서 부작용을 없애는 방법도 있다. 불변 객체는 인스턴스화한 다음에는 객체의 상태를 바꿀 수 없는 객체이므로 함수 동작에 영향을 받지 않는다.

따라서 불변 객체는 복사하지 않고 공유할 수 있으며, 객체의 상태를 바꿀 수 없으므로 스레드 안정성을 제공한다.

### 선언형 프로그래밍

프로그램으로 시스템을 구현하는 방식은 크게 두 가지로 구분할 수 있다.

'이 일을 먼저하고 그 다음에 저 값을 갱신하고....' 처럼 작업을 어떻게 수행할 것인지에 집중하는 방법이 있다.

'어떻게'가  아닌 '무엇을'에 집중하는 방식도 있다.

```java
Optioanl<Transaction> mostExpensive = transactions.stream()
																									.max(comparing(Transaction::getValue));
```

위와 같은 구현 방식을 `내부반복`이라고 한다.

질의문 자체로 문제를 어떻게 푸는지 명확하게 보여준다는 것이 내부 반복 프로그래밍의 큰 장점이다.

### 왜 함수형 프로그래밍인가?

함수형 프로그래밍은 선언형 프로그래밍을 따르는 대표적인 방식이며, 부작용이 없는 계산을 지향한다.

함수형 프로그래밍을 이용하면 부작용이 없는 복잡하고 어려운 기능을 수행하는 프로그램을 구현할 수 있다.

### 함수형 프로그래밍이란 무엇인가?

'함수형 프로그래밍이란 무엇인가?'라는 질문에 '함수를 이용하는 프로그래밍이다' 라고 간단히 답변할 수 있다.

'그럼 함수란 무엇인가?'라는 질문이 다시 꼬리를 문다.

함수형 프로그래밍에서 함수란 수학적인 `함수`와 같다. 즉, 함수는 0개 이상의 인수를 가지며, 한 개 이상의 결과를 반환하지만 `부작용이 없어야 한다.`

![chapter18%20%E1%84%92%E1%85%A1%E1%86%B7%E1%84%89%E1%85%AE%E1%84%92%E1%85%A7%E1%86%BC%20%E1%84%80%E1%85%AA%E1%86%AB%E1%84%8C%E1%85%A5%E1%86%B7%E1%84%8B%E1%85%B3%E1%84%85%E1%85%A9%20%E1%84%89%E1%85%A2%E1%86%BC%E1%84%80%E1%85%A1%E1%86%A8%E1%84%92%E1%85%A1%E1%84%80%E1%85%B5%2074f084ea904e450ba3f59dc3a5fb581c/Untitled%201.png](chapter18%20%E1%84%92%E1%85%A1%E1%86%B7%E1%84%89%E1%85%AE%E1%84%92%E1%85%A7%E1%86%BC%20%E1%84%80%E1%85%AA%E1%86%AB%E1%84%8C%E1%85%A5%E1%86%B7%E1%84%8B%E1%85%B3%E1%84%85%E1%85%A9%20%E1%84%89%E1%85%A2%E1%86%BC%E1%84%80%E1%85%A1%E1%86%A8%E1%84%92%E1%85%A1%E1%84%80%E1%85%B5%2074f084ea904e450ba3f59dc3a5fb581c/Untitled%201.png)

![chapter18%20%E1%84%92%E1%85%A1%E1%86%B7%E1%84%89%E1%85%AE%E1%84%92%E1%85%A7%E1%86%BC%20%E1%84%80%E1%85%AA%E1%86%AB%E1%84%8C%E1%85%A5%E1%86%B7%E1%84%8B%E1%85%B3%E1%84%85%E1%85%A9%20%E1%84%89%E1%85%A2%E1%86%BC%E1%84%80%E1%85%A1%E1%86%A8%E1%84%92%E1%85%A1%E1%84%80%E1%85%B5%2074f084ea904e450ba3f59dc3a5fb581c/Untitled%202.png](chapter18%20%E1%84%92%E1%85%A1%E1%86%B7%E1%84%89%E1%85%AE%E1%84%92%E1%85%A7%E1%86%BC%20%E1%84%80%E1%85%AA%E1%86%AB%E1%84%8C%E1%85%A5%E1%86%B7%E1%84%8B%E1%85%B3%E1%84%85%E1%85%A9%20%E1%84%89%E1%85%A2%E1%86%BC%E1%84%80%E1%85%A1%E1%86%A8%E1%84%92%E1%85%A1%E1%84%80%E1%85%B5%2074f084ea904e450ba3f59dc3a5fb581c/Untitled%202.png)

## 함수형 자바

실질적으로 자바로는 완벽한 순수 함수형 프로그래밍을 구현하기 어렵다. 하지만 순수 함수형이 아니라 함수형 프로그램을 구현할 수 있다.

실제 부작용이 있지만 아무도 이를 보지 못하게 함으로써 함수형을 달성할 수 있다.

함수나 메서드는 지역 변수만을 변경해야 함수형이라 할 수 있다. 그리고 함수나 메서드에서 참조하는 객체가 있다면 그 객체는 불변 객체여야 한다. 즉, 객체의 모든 필드가 final이어야 하고 모든 참조 필드는 불변 객체를 직접 참조해야한다.

함수형이라면 함수나 메서드가 어떤 예외도 일으키지 않아야 한다. 수학적 함수는 주어진 인수값에 대응하는 하나의 결과를 반환한다.

## 참조 투명성

'부작용을 감춰야 한다' 라는 제약은 참조 투명성 개념으로 귀결된다. 즉, 같은 인수로 함수를 호출했을 때 항상 같은 결과를 반환한다면 참조적으로 투명한 함수라고 표현한다.

```java
"raoul".replace('r', 'R')
```

위와 같은 코드는 항상 같은 결과가 나오므로 String.replace는 참조적으로 투명하다.

다시 말해, 함수는 어떤 입력이 주어졌을 때 언제, 어디서 호출하든 같은 결과를 생성해야 한다. 따라서 Random.nextInt는 함수형이 될 수 없다.

참조 투명성은 프로그램 이해에 큰 도움을 준다. 또한 참조 투명성은 비싸거나 오랜 시간이 걸리는 연산을 `기억화` 또는 `캐싱`을 통해 다시 계산하지 않고 저장하는 최적화 기능도 제공한다.

자바에는 참조 투명성과 관련한 작은 문제가 있다.

List를 반환하는 메서드를 두 번 호출한다고 가정하자. 두 번의 호출 결과로 같은 요소를 포함하지만 서로 다른 메모리 공간에 생성된 리스트를 참조할 것이다. 결과 리스트가 가변 객체라면 리스트를 반환하는 메서드는 참조적으로 투명한 메서드가 아니라는 결론이 나온다.

결과 List를 (불변의) 순수값으로 사용할 것이라면 두 리스트가 같은 객체라고 볼 수 있으므로 리스트 생성 함수는 참조적으로 투명한 것으로 간주할 수 있다.

# 마치며

- 공유된 가변 자료구조를 줄이는 것은 장기적으로 프로그램을 유지보수하고 디버깅하는데 도움이 된다.
- 함수형 프로그래밍은 부작용이 없는 메서드와 선언형 프로그래밍 방식을 지향한다.
- 함수형 메서드는 입력 인수와 출력 결과만을 갖는다.
- 같은 인수값으로 함수를 호출했을 때 항상 같은 값을 반환하면 참조 투명성을 갖는 함수다.