# ë™ì‘íŒŒë¼ë¯¸í„°í™”

## - "ë™ì‘íŒŒë¼ë¯¸í„°í™”" ë€?

- ë©”ì„œë“œë¥¼ ë‹¤ë¥¸ ë©”ì„œë“œì˜ ì¸ìˆ˜ë¡œ ë„˜ê²¨ì£¼ëŠ” ê¸°ëŠ¥ìœ¼ë¡œ java8ì—ì„œ ì¶”ê°€ëœ ê¸°ëŠ¥ì´ë‹¤!
- ì¸ìˆ˜ë¡œ ì „ë‹¬ëœ ë©”ì†Œë“œëŠ” ë‚˜ì¤‘ì— í”„ë¡œê·¸ë¨ì—ì„œ í•´ë‹¹ ë©”ì†Œë“œê°€ í˜¸ì¶œë˜ì–´ ì‹¤í–‰ë ë•Œ ê°’ì´ ë“¤ì–´ê°€ë¯€ë¡œ ì–´ë–»ê²Œ ì‹¤í–‰í•  ê²ƒì¸ì§€ ê²°ì •í•˜ì§€ ì•Šì€ ì½”ë“œ ë¸”ëŸ­ì´ë¼ê³  ë³¼ ìˆ˜ ìˆë‹¤.
- ìì£¼ ë°”ë€ŒëŠ” ìš”êµ¬ì‚¬í•­ì— íš¨ê³¼ì ì¸ ëŒ€ì‘ì´ ê°€ëŠ¥í•´ì§€ëŠ” ì¥ì ì„ ê°€ì§€ê³  ìˆë‹¤.

ì¦‰, ë©”ì†Œë“œë¥¼ ë©”ì†Œë“œì˜ ì¸ìˆ˜ë¡œ ì „ë‹¬í•˜ëŠ” ê²ƒì¸ë° ê·¸ë ‡ë‹¤ë©´ ìì£¼ ë°”ë€ŒëŠ” ìš”êµ¬ì‚¬í•­ì— ëŒ€ì‘ì´ íš¨ê³¼ì ì´ë¼ëŠ” ê²ƒì€ ì–´ë–¤ ì˜ë¯¸ì¼ê¹Œ? ì½”ë“œë¥¼ í†µí•´ ì´í•´í•´ë³´ì.

```java
// ì›í•˜ëŠ” ìƒ‰ê¹” ì‚¬ê³¼ í•„í„°ë§ - íŒŒë¼ë¯¸í„°ë¡œ ì›í•˜ëŠ” ìƒ‰ ì „ë‹¬
public static List<Apple> filterGreenApples(List<Apple> inventory, Color color){
	List<Apple> result = new ArrayList<>(); 
	for (Apple apple : inventory) {
			if(color.equals(apple.getColor()) {
					result.add(apple); // ì›í•˜ëŠ” ìƒ‰ì¸ ì‚¬ê³¼ë§Œ ì¶”ê°€
			}
	}
	return result;
}

// ì¼ì • ë¬´ê²Œ ì´ìƒì˜ ì‚¬ê³¼ í•„í„°ë§ - íŒŒë¼ë¯¸í„°ë¡œ ì›í•˜ëŠ” ë¬´ê²Œ ê¸°ì¤€ ì „ë‹¬
public static List<Apple> filterGreenApples(List<Apple> inventory, int weight){
	List<Apple> result = new ArrayList<>(); 
	for (Apple apple : inventory) {
			if(apple.getWeight() > weight) {
					result.add(apple); // ì›í•˜ëŠ” ê¸°ì¤€ ë¬´ê²Œë¥¼ ì¶©ì¡±í•œ ì‚¬ê³¼ë§Œ ì¶”ê°€
			}
	}
	return result;
}

// ì›í•˜ëŠ” ìƒ‰ê³¼ ë¬´ê²Œ ê¸°ì¤€ì„ ëª¨ë‘ ë§Œì¡±í•˜ëŠ” ì‚¬ê³¼ í•„í„°ë§ - ë™ì¼í•˜ê²Œ íŒŒë¼ë¯¸í„°ë¡œ ì „ë‹¬
public static List<Apple> filterGreenApples(List<Apple> inventory, Color color, 
																												int weight, boolean flag){
	List<Apple> result = new ArrayList<>(); 
	for (Apple apple : inventory) {
			if((flag && color.equals(apple.getColor())) ||
					(!flag && apple.getWeight() > weight)) {
					result.add(apple); // ì›í•˜ëŠ” ìƒ‰ì„ ê°€ì§„ ê¸°ì¤€ë¬´ê²Œ ì´ìƒ ì‚¬ê³¼ë§Œ ì¶”ê°€
			}
	}
	return result;
}
```

í•´ë‹¹ ì½”ë“œë¥¼ ì‚´í´ë³´ë©´, 

ì‚¬ìš©ìê°€ ì›í•˜ëŠ” ê¸°ì¤€ì´ ëŠ˜ì–´ë‚˜ê²Œ ë˜ë©´ ê·¸ë•Œë§ˆë‹¤ ë©”ì†Œë“œë¥¼ ìƒˆë¡œ ë§Œë“¤ì–´ ë¹„ìŠ·í•œ í•„í„°ë§ ì‘ì—…ì„ ë°˜ë³µí•˜ë©° ì›í•˜ëŠ” ê¸°ì¤€ì´ ëŠ˜ì–´ë‚˜ëŠ” ë§Œí¼ íŒŒë¼ë¯¸í„°ë„ ëŠ˜ì–´ë‚˜ê²Œ ëœë‹¤.. ğŸ¥´ 

í•´ë‹¹ ì‘ì—…ì— ë™ì‘ íŒŒë¼ë¯¸í„°í™” ê¸°ëŠ¥ì„ ì‚¬ìš©í•˜ê²Œ ë˜ë©´ ì´ëŸ° ë¬¸ì œì ë“¤ì´ í•´ì†Œë  ìˆ˜ ìˆë‹¤.

ì›í•˜ëŠ” í•„í„°ë§ ê¸°ì¤€ì„ ë©”ì†Œë“œë¡œ ì „ë‹¬í•˜ì—¬ ê¸°ì¤€ì´ ëŠ˜ì–´ë‚˜ê±°ë‚˜ í˜¹ì€ ë‹¤ì–‘í•œ ê¸°ì¤€ìš”ì†Œë“¤ì— ëŒ€í•œ 

ìœ ì—°í•œ ëŒ€ì²˜ë¥¼ ê°€ëŠ¥í•˜ê²Œ í•´ì£¼ëŠ” ê²ƒì´ë‹¤.

ê·¸ë ‡ë‹¤ë©´ ìœ„ì˜ í•„í„°ë§ ë©”ì†Œë“œë¥¼ ë™ì‘ íŒŒë¼ë¯¸í„°í™”ë¥¼ ì´ìš©í•˜ì—¬ êµ¬í˜„í•´ë³´ì!

```java
// ì‚¬ê³¼ í•„í„°ë§ ë©”ì†Œë“œ - ì›í•˜ëŠ” í•„í„°ë§ ì¡°ê±´ì„ ë™ì‘íŒŒë¼ë¯¸í„°í™”ë¥¼ ì´ìš©í•˜ì—¬ ì „ë‹¬
public static List<Apple> filterApples(List<Apple> inventory, ApplePredicate p){
	
	List<Apple> result = new ArrayList<>();
	for(Apple apple : inventory) {
			if(p.test(apple)) { //predicate ê°ì²´ë¥¼ ì´ìš©í•˜ì—¬ ì‚¬ê³¼ í•„í„°ë§
					result.add(apple);
			}
	}
}
```

ìœ„ì™€ ê°™ì´ ì‚¬ê³¼ í•„í„°ë§ ë©”ì†Œë“œëŠ” ìœ ì—°ì ì¸ ì¡°ê±´ì— ëŒ€ì²˜í•  ìˆ˜ ìˆë„ë¡ ë§Œë“¤ì–´ ë†“ëŠ”ë‹¤.

ê·¸ë ‡ë‹¤ë©´ ì¡°ê±´ì€ ì–´ë–»ê²Œ ì „ë‹¬í• ê¹Œ? ApplePredicate ëŠ” ì–´ë–¤ê±¸ê¹Œ? 

```java
public interface ApplePredicate {
	boolean test(Apple apple);
}

public class AppleHeavyWeightPredicate implements ApplePredicate{
	public boolean test(Apple apple){
		return apple.getWeight() > 150;
	}
}

public class GreenApplePredicate implements ApplePredicate{
	public boolean test(Apple apple){
		return "GREEN".equals(apple.getColor());
	}
}
```

ìœ„ ì½”ë“œëŠ” ê°ê° 150  ì´ìƒì˜ ë¬´ê²Œë¥¼ ê°€ì§„ ì‚¬ê³¼ í•„í„°ë§, ë…¹ìƒ‰ ì‚¬ê³¼ í•„í„°ë§ì„ predicateë¥¼ ì´ìš©í•˜ì—¬

êµ¬í˜„í•œ ê²ƒì´ë‹¤. 

ìœ„ ì½”ë“œë¥¼ ì´í•´í•˜ê¸° ìœ„í•´ì„œ ë¨¼ì € Predicateì— ëŒ€í•´ ì•Œì•„ë³´ì.

---

- Predicate

    1) í•¨ìˆ˜í˜• ì¸í„°í˜ì´ìŠ¤ë‹¤.

    2) ë§¤ê°œê°’ 1ê°œ ë°˜í™˜ê°’ì€ boolean  í˜•ì‹ì¸ ì¸í„°í˜ì´ìŠ¤ë‹¤.

    3) ê¸°ë³¸ ì¶”ìƒ í•¨ìˆ˜ì¸ test í•¨ìˆ˜ë¥¼ ê°€ì§€ê³  ìˆìœ¼ë©°, and, or, negateì™€ ê°™ì€ ì¡°ê±´ ê²€ì‚¬ë„ ê°€ëŠ¥í•˜ë‹¤.

    ```java
    @FunctionalInterface
    public interface Predicate<T> {

        /**
         * Evaluates this predicate on the given argument.
         *
         * @param t the input argument
         * @return {@code true} if the input argument matches the predicate,
         * otherwise {@code false}
         */
        boolean test(T t);

        /**
         * Returns a composed predicate that represents a short-circuiting logical
         * AND of this predicate and another.  When evaluating the composed
         * predicate, if this predicate is {@code false}, then the {@code other}
         * predicate is not evaluated.
         *
         * <p>Any exceptions thrown during evaluation of either predicate are relayed
         * to the caller; if evaluation of this predicate throws an exception, the
         * {@code other} predicate will not be evaluated.
         *
         * @param other a predicate that will be logically-ANDed with this
         *              predicate
         * @return a composed predicate that represents the short-circuiting logical
         * AND of this predicate and the {@code other} predicate
         * @throws NullPointerException if other is null
         */
        default Predicate<T> and(Predicate<? super T> other) {
            Objects.requireNonNull(other);
            return (t) -> test(t) && other.test(t);
        }

        /**
         * Returns a predicate that represents the logical negation of this
         * predicate.
         *
         * @return a predicate that represents the logical negation of this
         * predicate
         */
        default Predicate<T> negate() {
            return (t) -> !test(t);
        }

        /**
         * Returns a composed predicate that represents a short-circuiting logical
         * OR of this predicate and another.  When evaluating the composed
         * predicate, if this predicate is {@code true}, then the {@code other}
         * predicate is not evaluated.
         *
         * <p>Any exceptions thrown during evaluation of either predicate are relayed
         * to the caller; if evaluation of this predicate throws an exception, the
         * {@code other} predicate will not be evaluated.
         *
         * @param other a predicate that will be logically-ORed with this
         *              predicate
         * @return a composed predicate that represents the short-circuiting logical
         * OR of this predicate and the {@code other} predicate
         * @throws NullPointerException if other is null
         */
        default Predicate<T> or(Predicate<? super T> other) {
            Objects.requireNonNull(other);
            return (t) -> test(t) || other.test(t);
        }

        /**
         * Returns a predicate that tests if two arguments are equal according
         * to {@link Objects#equals(Object, Object)}.
         *
         * @param <T> the type of arguments to the predicate
         * @param targetRef the object reference with which to compare for equality,
         *               which may be {@code null}
         * @return a predicate that tests if two arguments are equal according
         * to {@link Objects#equals(Object, Object)}
         */
        static <T> Predicate<T> isEqual(Object targetRef) {
            return (null == targetRef)
                    ? Objects::isNull
                    : object -> targetRef.equals(object);
        }
    }
    ```

    â‡’ í•´ë‹¹ ì¸í„°í˜ì´ìŠ¤ë¥¼ êµ¬í˜„í•˜ëŠ” í´ë˜ìŠ¤ì—ì„œ 

    ì–´ë– í•œ ì¡°ê±´ì„ ë§Œì¡±í•˜ëŠ”ì§€ ê·¸ ê²°ê³¼ê°’ì„ ë°›ê³  ì‹¶ë‹¤ë©´ ê¸°ë³¸ì ìœ¼ë¡œ testë¥¼ ì‚¬ìš©í•˜ì§€ë§Œ,

    ë‘ê°€ì§€ ì¡°ê±´ì„ andë‚˜ orë¡œ ë§Œì¡±í•˜ëŠ”ì§€ í˜¹ì€ trueì¼ë•Œ false ê°’ì„ ë‚´ë±‰ëŠ” ê²°ê³¼ë¥¼ ì–»ê³  ì‹¶ì„ë•Œ 

    ìœ„ì˜ ì¸í„°í˜ì´ìŠ¤ë¥¼ ì‚¬ìš©í•  ìˆ˜ ìˆë‹¤.  

    ---

ì´ìƒ filterApplesì˜ ë™ì‘ì„ íŒŒë¼ë¯¸í„°í™” í•˜ì—¬ 

ë‹¤ì–‘í•œ í•„í„°ë§ì„ ìœ ì—°í•˜ê²Œ ì „ë‹¬í•  ìˆ˜ ìˆë„ë¡ ì½”ë”©í•´ë³´ì•˜ë‹¤.

ì´ ê³¼ì •ì—ì„œ Predicate ë¥¼ ì´ìš©í•˜ì—¬ í•„í„°ë§ì„ ì „ë‹¬í•˜ì˜€ëŠ”ë°..

QA) ì‚¬ì‹¤ìƒ . í•„í„°ë§ì´ ìœ„ì™€ ê°™ì´ ëœë‹¤ë©´.. í•„í„° ì¡°ê±´ì— ë”°ë¼ í•„í„°ë§ì„ ê³„ì† ì¶”ê°€í•´ì•¼í•˜ëŠ”ê²Œ ì•„ë‹Œì§€..

ê·¸ëŸ¼ ì–´ë–¤ ì˜ë¯¸ê°€ ìˆì„ì§€ëŠ” ì•„ì§ ëª¨ë¥´ê² ë‹¤....
